#![no_main]
sp1_zkvm::entrypoint!(main);

use sp1_zkvm::io;
use sha2::{Sha256, Digest};

/// x402 Identity Circuit - Merkle Tree Version
///
/// Proves: "I know a secret that is in the authorized Merkle tree"
/// Reveals: Nothing about which agent or what secret
///
/// Scales to unlimited agents. Just update the MERKLE_ROOT.

// Merkle root of all authorized agents
// Generated by: python merkle_tree.py
const MERKLE_ROOT: &str = "263f639b87bbf5e98a3099282ffed1eca3bd946818592b0bda8fe546426afc2b";

/// Hash a byte array with SHA256
fn sha256_bytes(data: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(data);
    let result = hasher.finalize();
    let mut output = [0u8; 32];
    output.copy_from_slice(&result);
    output
}

/// Hash a string to get leaf node
fn hash_leaf(secret: &str) -> [u8; 32] {
    sha256_bytes(secret.as_bytes())
}

/// Hash two nodes together (left || right)
fn hash_pair(left: &[u8; 32], right: &[u8; 32]) -> [u8; 32] {
    let mut combined = Vec::with_capacity(64);
    combined.extend_from_slice(left);
    combined.extend_from_slice(right);
    sha256_bytes(&combined)
}

/// Convert hex string to bytes
fn hex_to_bytes32(hex: &str) -> [u8; 32] {
    let mut bytes = [0u8; 32];
    for i in 0..32 {
        bytes[i] = u8::from_str_radix(&hex[i*2..i*2+2], 16).unwrap();
    }
    bytes
}

pub fn main() {
    // === PRIVATE INPUTS ===
    // Agent's secret (never revealed)
    let secret: String = io::read();
    // Merkle proof: list of sibling hashes
    let proof_siblings: Vec<String> = io::read();
    // Direction bits: true = sibling is on left
    let proof_directions: Vec<bool> = io::read();

    // === COMPUTE ===
    // Start with leaf hash of our secret
    let mut current_hash = hash_leaf(&secret);

    // Walk up the tree using the proof
    for (sibling_hex, sibling_is_left) in proof_siblings.iter().zip(proof_directions.iter()) {
        let sibling = hex_to_bytes32(sibling_hex);

        if *sibling_is_left {
            // Sibling is on left, we're on right
            current_hash = hash_pair(&sibling, &current_hash);
        } else {
            // We're on left, sibling is on right
            current_hash = hash_pair(&current_hash, &sibling);
        }
    }

    // === CONSTRAINT ===
    // Final hash must equal the Merkle root
    let expected_root = hex_to_bytes32(MERKLE_ROOT);

    assert_eq!(
        current_hash,
        expected_root,
        "ACCESS DENIED: Identity not in registry"
    );

    // === PUBLIC OUTPUT ===
    // Only reveals: "yes, this agent is authorized"
    // Never reveals: which agent, what secret, or tree position
    io::commit(&true);
}
