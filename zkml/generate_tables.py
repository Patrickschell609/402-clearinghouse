#!/usr/bin/env python3
"""
╔══════════════════════════════════════════════════════════════════╗
║   EXP LOOKUP TABLE GENERATOR                                     ║
║   For zkML Softmax in SP1 zkVM                                   ║
║                                                                  ║
║   Creates 2^14 entry exp lookup table for stable softmax         ║
║   Domain: [-10, 0] (post max-subtraction range)                  ║
║   Output: Rust array of u32 values                               ║
╚══════════════════════════════════════════════════════════════════╝
"""

import numpy as np
import json

# Table parameters
TABLE_BITS = 14
TABLE_SIZE = 1 << TABLE_BITS  # 16384 entries

# Domain: exp(x) for x in [-10, 0]
# After subtracting max for numerical stability, attention scores
# are in this range (practically)
X_MIN = -10.0
X_MAX = 0.0

# Fixed-point scale: 2^24 gives good precision
# exp(0) * 2^24 = 16,777,216 (fits in u32)
# exp(-10) * 2^24 ≈ 761
SCALE_BITS = 24
SCALE = 1 << SCALE_BITS


def generate_exp_table():
    """Generate exp lookup table with 2^14 entries."""
    table = []

    for i in range(TABLE_SIZE):
        # Map index to x value: i=0 -> x=-10, i=16383 -> x=0
        x = X_MIN + (i / (TABLE_SIZE - 1)) * (X_MAX - X_MIN)

        # Compute exp(x) and scale to fixed point
        exp_val = np.exp(x)
        scaled = int(round(exp_val * SCALE))

        # Clamp to u32 range (shouldn't be needed but safety)
        scaled = max(0, min(scaled, 0xFFFFFFFF))

        table.append(scaled)

    return table


def verify_table(table):
    """Verify table accuracy against float32 reference."""
    max_rel_error = 0.0
    max_abs_error = 0.0

    # Test 1000 random points
    test_points = np.linspace(X_MIN, X_MAX, 1000)

    for x in test_points:
        # Reference
        ref = np.exp(x)

        # Table lookup with interpolation
        idx_float = (x - X_MIN) / (X_MAX - X_MIN) * (TABLE_SIZE - 1)
        idx_low = int(np.floor(idx_float))
        idx_high = min(idx_low + 1, TABLE_SIZE - 1)
        frac = idx_float - idx_low

        # Linear interpolation
        val_low = table[idx_low] / SCALE
        val_high = table[idx_high] / SCALE
        approx = val_low + frac * (val_high - val_low)

        # Errors
        abs_error = abs(ref - approx)
        rel_error = abs_error / ref if ref > 0 else 0

        max_abs_error = max(max_abs_error, abs_error)
        max_rel_error = max(max_rel_error, rel_error)

    return max_rel_error, max_abs_error


def generate_rust_code(table):
    """Generate Rust source code with the table and helpers."""

    rust_code = '''//! ╔══════════════════════════════════════════════════════════════════╗
//! ║   EXP LOOKUP TABLE FOR SOFTMAX                                   ║
//! ║   Auto-generated by generate_tables.py                           ║
//! ║                                                                  ║
//! ║   Domain: [-10, 0]                                               ║
//! ║   Entries: 16384 (2^14)                                          ║
//! ║   Scale: 2^24 fixed-point                                        ║
//! ╚══════════════════════════════════════════════════════════════════╝

/// Table parameters
pub const TABLE_BITS: u32 = 14;
pub const TABLE_SIZE: usize = 1 << TABLE_BITS;  // 16384
pub const SCALE_BITS: u32 = 24;
pub const SCALE: u32 = 1 << SCALE_BITS;  // 16777216

/// Domain bounds (fixed-point Q8.24 representation)
/// X_MIN = -10.0, X_MAX = 0.0
pub const X_MIN_SCALED: i32 = -167772160;  // -10 << 24
pub const X_MAX_SCALED: i32 = 0;           // 0 << 24
pub const X_RANGE_SCALED: i32 = 167772160; // 10 << 24

/// Exp lookup table: exp(x) for x in [-10, 0]
/// Values are scaled by 2^24
pub static EXP_TABLE: [u32; TABLE_SIZE] = [
'''

    # Add table entries (8 per line for readability)
    for i in range(0, TABLE_SIZE, 8):
        chunk = table[i:i+8]
        line = "    " + ", ".join(f"{v:>8}" for v in chunk) + ","
        rust_code += line + "\n"

    rust_code += '''];

/// Look up exp(x) using the table with linear interpolation
///
/// # Arguments
/// * `x_scaled` - Input value in Q8.24 fixed-point (x << 24)
///                Must be in range [X_MIN_SCALED, X_MAX_SCALED]
///
/// # Returns
/// * exp(x) in Q8.24 fixed-point
pub fn exp_lookup(x_scaled: i32) -> u32 {
    // Clamp to valid range
    let x_clamped = x_scaled.max(X_MIN_SCALED).min(X_MAX_SCALED);

    // Map x to table index
    // idx = (x - X_MIN) / X_RANGE * (TABLE_SIZE - 1)
    // Using fixed-point arithmetic:
    let offset = (x_clamped - X_MIN_SCALED) as u64;
    let idx_scaled = offset * (TABLE_SIZE as u64 - 1);
    let idx_full = idx_scaled / (X_RANGE_SCALED as u64);

    let idx_low = idx_full as usize;
    let idx_high = (idx_low + 1).min(TABLE_SIZE - 1);

    // Fractional part for interpolation (0 to 2^24)
    let frac_scaled = idx_scaled % (X_RANGE_SCALED as u64);
    let frac = (frac_scaled * (1 << SCALE_BITS) / (X_RANGE_SCALED as u64)) as u32;

    // Linear interpolation
    let val_low = EXP_TABLE[idx_low];
    let val_high = EXP_TABLE[idx_high];

    if val_high >= val_low {
        val_low + ((val_high - val_low) as u64 * frac as u64 >> SCALE_BITS) as u32
    } else {
        val_low - ((val_low - val_high) as u64 * frac as u64 >> SCALE_BITS) as u32
    }
}

/// Compute exp(x) without table (for testing/comparison)
/// Uses Taylor series: exp(x) ≈ 1 + x + x²/2 + x³/6 + x⁴/24 + x⁵/120
///
/// # Arguments
/// * `x_scaled` - Input in Q8.24, should be small (|x| < 1)
pub fn exp_taylor(x_scaled: i32) -> u32 {
    let scale = SCALE as i64;
    let x = x_scaled as i64;

    // Terms
    let term0: i64 = scale;                           // 1
    let term1: i64 = x;                               // x
    let term2: i64 = (x * x) / scale / 2;             // x²/2
    let term3: i64 = (x * x / scale * x) / scale / 6; // x³/6

    let result = term0 + term1 + term2 + term3;
    result.max(0).min(u32::MAX as i64) as u32
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_exp_at_zero() {
        // exp(0) should be 1.0 = SCALE
        let result = exp_lookup(0);
        let expected = SCALE;
        let error = (result as i64 - expected as i64).abs() as f64 / expected as f64;
        assert!(error < 1e-4, "exp(0) error too large: {}", error);
    }

    #[test]
    fn test_exp_at_minus_one() {
        // exp(-1) ≈ 0.3679
        let x = -1i32 << SCALE_BITS;
        let result = exp_lookup(x);
        let expected = (0.36787944 * SCALE as f64) as u32;
        let error = (result as i64 - expected as i64).abs() as f64 / expected as f64;
        assert!(error < 1e-4, "exp(-1) error: {}", error);
    }

    #[test]
    fn test_exp_at_minus_ten() {
        // exp(-10) ≈ 0.0000454
        let x = -10i32 * (1 << SCALE_BITS);
        let result = exp_lookup(x);
        let expected = (0.0000454 * SCALE as f64) as u32;
        let error = (result as i64 - expected as i64).abs() as f64 / expected as f64;
        assert!(error < 1e-3, "exp(-10) error: {}", error);  // Relaxed for edge
    }
}
'''

    return rust_code


def main():
    print("╔══════════════════════════════════════════════════════════════╗")
    print("║   EXP TABLE GENERATOR                                       ║")
    print("╚══════════════════════════════════════════════════════════════╝")
    print()

    # Generate table
    print(f"[*] Generating {TABLE_SIZE} entry exp table...")
    table = generate_exp_table()

    # Verify accuracy
    print("[*] Verifying table accuracy...")
    max_rel, max_abs = verify_table(table)
    print(f"    Max relative error: {max_rel:.2e}")
    print(f"    Max absolute error: {max_abs:.2e}")

    if max_rel < 1e-4:
        print("    [✓] Accuracy target met (<1e-4 relative error)")
    else:
        print("    [!] Accuracy below target")

    # Print sample values
    print()
    print("[*] Sample table values:")
    print(f"    exp(-10) scaled = {table[0]:>10} (float: {table[0]/SCALE:.6f})")
    print(f"    exp(-5)  scaled = {table[TABLE_SIZE//2]:>10} (float: {table[TABLE_SIZE//2]/SCALE:.6f})")
    print(f"    exp(0)   scaled = {table[-1]:>10} (float: {table[-1]/SCALE:.6f})")

    # Generate Rust code
    print()
    print("[*] Generating Rust source code...")
    rust_code = generate_rust_code(table)

    output_path = "program/src/exp_table.rs"
    with open(output_path, "w") as f:
        f.write(rust_code)
    print(f"    [✓] Written to {output_path}")

    # Also save raw table as JSON for debugging
    json_path = "exp_table.json"
    with open(json_path, "w") as f:
        json.dump({
            "table_size": TABLE_SIZE,
            "scale_bits": SCALE_BITS,
            "x_min": X_MIN,
            "x_max": X_MAX,
            "table": table
        }, f)
    print(f"    [✓] JSON backup: {json_path}")

    print()
    print("[✓] Table generation complete!")
    print()
    print("Next: cargo build in program/ to verify Rust compilation")


if __name__ == "__main__":
    main()
